# Kinova 遥操作系统 - 架构说明

> **5分钟快速理解整个系统** 🚀

## 一、系统概览

这是一个用 Apple Vision Pro 遥操作 Kinova Gen3 机械臂的系统，20Hz 运行，包含完整的安全监控和数据记录功能。

```
┌─────────────────────────────────────────────────────────────────┐
│                   Kinova Gen3 遥操作系统                          │
│                        (20Hz 主循环)                              │
└─────────────────────────────────────────────────────────────────┘

输入设备:                     核心模块:                    输出:
┌─────────────┐              ┌──────────────────┐        ┌─────────┐
│ Vision Pro  │─────────────→│ ReferenceFrame   │───┐    │ Kinova  │
│  (手部姿态)  │              │    Manager       │   │    │  Gen3   │
└─────────────┘              └──────────────────┘   │    │ (ROS2)  │
                                                    ↓    └─────────┘
┌─────────────┐              ┌──────────────────┐ ↓
│   手柄      │─────────────→│ InputAggregator  │ │    ┌──────────┐
│ (A键/扳机)  │              └──────────────────┘ │    │  HDF5    │
└─────────────┘                                   │    │ 数据记录  │
                             ┌──────────────────┐ │    └──────────┘
                             │ SafetyMonitor    │←┘
                             └──────────────────┘
                                      ↓
                             ┌──────────────────┐
                             │ MotionPlanner    │
                             │   (IK + 轨迹)    │
                             └──────────────────┘
                                      ↓
                             ┌──────────────────┐
                             │ RobotInterface   │
                             └──────────────────┘
```

---

## 二、六大核心模块

### 📍 1. ReferenceFrameManager (坐标变换管理器)

**作用**: 把 Vision Pro 的手部坐标从"相对头部"转换到"相对桌面"

```python
# kinova_teleoperation/modules/reference_frame_manager.py

输入: Vision Pro 头部姿态 + 手部姿态
处理:
  1. 世界坐标校准 (开机时记录头部位置作为原点)
  2. OneEuroFilter 平滑滤波 (减少抖动)
  3. 速度估计 (用于预测轨迹)
输出: 桌面坐标系下的手部位置 [x, y, z]
```

**关键参数**:
- `min_cutoff=1.0` - 滤波器截止频率
- `beta=0.05` - 速度自适应系数

---

### 🎮 2. InputAggregator (手柄输入聚合器)

**作用**: 统一处理 Xbox/PS 手柄输入

```python
# kinova_teleoperation/modules/input_aggregator.py

输入: 手柄按键/摇杆/扳机
处理:
  1. 按键边缘检测 (just_pressed 事件)
  2. 扳机死区处理 (deadband=0.1)
  3. 缩放模式切换 (Y键: 快速模式 ↔ 精确模式)
输出: GamepadState 数据类
```

**手柄映射**:
| 按键 | 功能 | 说明 |
|------|------|------|
| **A** | Clutch (离合) | 按住才能控制机器人 |
| **Y** | 模式切换 | 快速 (1.5x) ↔ 精确 (0.5x) |
| **右扳机** | 夹爪控制 | 0=张开, 1=闭合 |
| **B** | 紧急停止 | 立即停止所有运动 |

---

### 🛡️ 3. SafetyMonitor (安全监控器)

**作用**: 实时监控系统健康状态，保护硬件安全

```python
# kinova_teleoperation/modules/safety_monitor.py

监控项:
  ✓ Vision Pro 数据延迟 (< 200ms)
  ✓ IK 成功率 (最近10次 > 50%)
  ✓ 关节跟踪误差 (< 0.2 rad)
  ✓ 工作空间边界 (防止撞桌子/超出范围)

工作空间限制:
  - X, Y: 圆柱形边界，半径 60cm
  - Z_min: 桌面高度 + 3cm (防撞桌)
  - Z_max: 1.0m
```

**触发安全停止的条件** (任一满足):
- Vision Pro 数据超时
- 连续 IK 失败超过 5 次
- 关节卡死 (误差过大)

---

### 🧮 4. MotionPlanner (运动规划器)

**作用**: 解算逆运动学(IK) + 生成预测轨迹

```python
# kinova_teleoperation/modules/motion_planner.py

输入: 目标位置 [x,y,z] + 目标姿态 [四元数]
处理:
  1. KDL IK 求解 → 得到 7 个关节角度
  2. 使用手部速度预测未来位置 (t+50ms, t+100ms, t+150ms)
  3. 生成 3 点轨迹窗口
输出: JointTrajectory (ROS2 轨迹消息)
```

**预测原理**:
```
当前手位置: P0
手部速度: V
预测点:
  P1 = P0 + V * 0.05  (50ms后)
  P2 = P0 + V * 0.10  (100ms后)
  P3 = P0 + V * 0.15  (150ms后)
```
这样可以减少控制延迟，机器人提前向运动方向移动。

---

### 📊 5. DataLogger (数据记录器)

**作用**: 自动记录演示数据，用于后续训练

```python
# kinova_teleoperation/modules/data_logger.py

触发: A键按下时自动开始录制
停止: A键松开时自动保存
格式: HDF5 (./demonstrations/demo_YYYYMMDD_HHMMSS.hdf5)

数据结构:
/observations/
  ├── images       (N, 480, 640, 3) - RGB 图像
  ├── qpos         (N, 7)           - 关节位置
  ├── qvel         (N, 7)           - 关节速度
  └── ee_pose      (N, 7)           - 末端位姿 [x,y,z,qx,qy,qz,qw]

/actions/
  ├── cartesian_delta  (N, 6)      - 笛卡尔增量 [dx,dy,dz,drx,dry,drz]
  └── joint_positions  (N, 7)      - 目标关节角度

/metadata/
  ├── task_name
  ├── start_time
  └── num_frames
```

---

### 🤖 6. RobotInterface (机器人接口)

**作用**: ROS2 通信封装

```python
# kinova_teleoperation/modules/robot_interface.py

功能:
  - 订阅 /my_gen3/joint_states (获取当前状态)
  - 发布 /my_gen3/joint_trajectory (发送控制指令)
  - 夹爪动作客户端 (发送夹爪命令)
  - 线程安全的状态缓存

关键方法:
  get_state()        → 获取当前机器人状态
  send_trajectory()  → 发送轨迹指令
  send_gripper()     → 控制夹爪
  hold_position()    → 保持当前位置
```

---

## 三、控制流程详解

### 主循环 (20Hz)

```python
# kinova_teleoperation/main_loop.py - _control_iteration()

每 50ms 执行一次:

1️⃣ 【感知阶段】
   ├─ Vision Pro 获取手部姿态 (head_pose, hand_pose_raw)
   ├─ ReferenceFrameManager 滤波 → hand_filtered
   ├─ 手柄获取按键状态 → gamepad_state
   └─ 机器人获取当前状态 → robot_state

2️⃣ 【安全检查】
   ├─ SafetyMonitor.check_system_health()
   └─ 如果不健康 → hold_position() + 返回

3️⃣ 【控制逻辑】
   如果 A 键按下:
      ├─ [首次按下] 记录锚点:
      │   ├─ anchor_hand_pose = 当前手部位置
      │   └─ anchor_robot_pose = 当前机器人末端位置
      │
      ├─ 计算增量:
      │   ├─ delta_hand = hand_filtered - anchor_hand_pose
      │   └─ delta_scaled = delta_hand * scaling_factors
      │
      ├─ 计算目标:
      │   └─ target_position = anchor_robot_pose + delta_scaled
      │
      ├─ 安全限制:
      │   └─ safe_position = clamp_to_workspace(target_position)
      │
      ├─ IK + 轨迹:
      │   ├─ joint_target = MotionPlanner.solve_ik()
      │   └─ trajectory = generate_trajectory_window()
      │
      ├─ 发送指令:
      │   ├─ RobotInterface.send_trajectory(trajectory)
      │   └─ RobotInterface.send_gripper(trigger_val)
      │
      └─ 数据记录:
          └─ DataLogger.log_frame()

   如果 A 键松开:
      ├─ hold_position()
      └─ 停止录制 → 保存 HDF5

4️⃣ 【紧急停止】
   如果 B 键按下 → 停止系统
```

---

## 四、关键概念

### 🔗 Clutch (离合) 机制

就像汽车离合器一样，控制"输入"和"输出"是否连接:

```
A 键按下 (Clutch Engaged):
  手移动 → 机器人跟着移动 ✅
  记录锚点 → 计算相对位移 → IK 求解 → 控制机器人

A 键松开 (Clutch Released):
  手移动 → 机器人不动 ❌
  机器人保持当前位置 (hold_position)
```

**为什么需要 Clutch?**
1. **安全**: 不会一直跟踪手的绝对位置
2. **灵活**: 可以重新调整手的位置而不影响机器人
3. **省力**: 不需要一直保持手臂姿势

---

### 📐 锚点 (Anchor) 机制

```python
# 首次按下 A 键时:
anchor_hand_pose = [0.2, 0.3, 0.5]      # 手的位置 (桌面坐标)
anchor_robot_pose = [0.4, 0.0, 0.3]     # 机器人末端位置

# 手移动后:
current_hand_pose = [0.25, 0.35, 0.55]  # 手移动了 (+5cm, +5cm, +5cm)

# 计算增量:
delta = current_hand_pose - anchor_hand_pose = [0.05, 0.05, 0.05]
delta_scaled = delta * [1.5, 1.5, 1.0] = [0.075, 0.075, 0.05]  # 应用缩放

# 计算目标:
target = anchor_robot_pose + delta_scaled = [0.475, 0.075, 0.35]
```

**核心思想**: 控制的是**相对位移**，而不是绝对位置！

---

### 🎯 缩放模式

| 模式 | XY 缩放 | Z 缩放 | 适用场景 |
|------|---------|--------|----------|
| **快速模式** | 1.5× | 1.0× | 大范围移动、快速定位 |
| **精确模式** | 0.5× | 0.5× | 精细操作、插入任务 |

按 Y 键切换，系统会更新 `self.scaling_factors`。

---

## 五、目录结构

```
kinova_teleoperation/
├── 架构说明.md                    ← 🎯 你现在看的文档
├── README.md                      ← 完整英文文档
├── QUICKSTART.md                  ← 快速开始指南
│
├── kinova_teleoperation/
│   ├── main_loop.py               ← 🚀 主程序 (20Hz 循环)
│   │
│   ├── modules/                   ← 📦 六大核心模块
│   │   ├── reference_frame_manager.py
│   │   ├── input_aggregator.py
│   │   ├── safety_monitor.py
│   │   ├── motion_planner.py
│   │   ├── data_logger.py
│   │   └── robot_interface.py
│   │
│   └── utils/                     ← 🛠️ 工具函数
│       └── one_euro_filter.py
│
├── config/                        ← ⚙️ 配置文件
│   ├── robot_config.yaml
│   └── safety_params.yaml
│
├── scripts/                       ← 🔧 辅助脚本
│   └── calibrate_table.py         (桌面高度校准)
│
└── demonstrations/                ← 💾 录制的演示数据
    └── demo_*.hdf5
```

---

## 六、快速上手

### 1. 启动机器人

```bash
ros2 launch kortex_bringup gen3.launch.py robot_ip:=192.168.1.10
```

### 2. 连接设备

- Vision Pro: 启动 streaming app，记下 IP
- 手柄: 插上 USB 或配对蓝牙

### 3. 运行系统

```bash
cd kinova_teleoperation

python3 -m kinova_teleoperation.main_loop \
    --vision-pro-ip 192.168.1.XXX \
    --robot-name my_gen3 \
    --config config/safety_params.yaml \
    --urdf ../ros2_kortex/kortex_description/arms/gen3/7dof/urdf/gen3_macro.xacro
```

### 4. 操作流程

1. 系统启动后会提示**校准世界坐标系** → 按回车
2. 按住 **A 键** → 开始控制
3. 移动手部 → 机器人跟随
4. 松开 **A 键** → 停止控制
5. 按 **Ctrl+C** → 关闭系统

---

## 七、与 kinova_data_collection 的对比

| 对比项 | kinova_teleoperation (你的) | kinova_data_collection |
|--------|----------------------------|----------------------|
| **ROS版本** | ROS2 Humble | ROS1 |
| **机器人** | Kinova Gen3 | Kinova Gen2 |
| **架构** | 模块化 (6个独立模块) | 继承式 (2层类) |
| **控制频率** | 20Hz (主循环) | 100Hz (PID) |
| **IK求解** | KDL (独立模块) | TracIK (集成在类里) |
| **安全系统** | SafetyMonitor 专门模块 | 分散在各处 |
| **数据记录** | DataLogger 自动录制 | 独立脚本 |
| **特点** | 完整系统工程，易维护 | 快速部署，高频控制 |

---

## 八、常见问题

### Q1: 为什么是 20Hz 而不是更高频率？

**A**:
- Vision Pro 数据更新频率 ≈ 20-30Hz
- IK 求解 + 轨迹生成需要 10-20ms
- 20Hz 是平衡实时性和计算负载的最优选择
- 通过轨迹预测弥补了延迟

### Q2: 如果 IK 失败怎么办？

**A**:
1. 系统调用 `hold_position()` 保持当前位置
2. 记录失败到 `ik_success_history`
3. SafetyMonitor 监控连续失败次数
4. 超过 5 次连续失败 → 触发安全停止

### Q3: 录制的数据可以直接用于训练吗？

**A**: 可以！HDF5 格式兼容 HIL-SERL 训练框架:
```python
import h5py
data = h5py.File('demo_xxx.hdf5', 'r')
obs = data['observations/qpos'][:]  # (N, 7)
act = data['actions/cartesian_delta'][:]  # (N, 6)
```

### Q4: 如何调试某个模块？

**A**: 每个模块都有 `__main__` 块，可以单独运行:
```bash
python3 -m kinova_teleoperation.modules.safety_monitor
python3 -m kinova_teleoperation.modules.motion_planner
```

---

## 九、进阶阅读

- **详细 API 文档**: 查看各模块的 docstring
- **英文完整文档**: `README.md`
- **快速开始**: `QUICKSTART.md`
- **技术文档**: `项目技术文档_中文.md`

---

## 🎓 总结

这个系统的核心设计思想是:
1. **模块化** - 每个模块职责单一，易于测试和维护
2. **安全优先** - 多重安全检查，保护硬件
3. **实时性** - 20Hz 循环 + 轨迹预测，减少延迟
4. **易用性** - Clutch 机制，操作直观安全

如果你只记住一件事，那就是: **这是一个用相对位移控制的系统，按住A键时手的增量会映射到机器人末端的增量！**

---

**祝你使用愉快！🚀**
